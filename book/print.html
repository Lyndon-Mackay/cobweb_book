<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cobweb book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> introduction</a></li><li class="chapter-item expanded "><a href="starting.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded affix "><li class="part-title">Cob File Format</li><li class="chapter-item expanded "><a href="cob_intro.html"><strong aria-hidden="true">3.</strong> Cob files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cob_fields.html"><strong aria-hidden="true">3.1.</strong> Loadable fields</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rust editing</li><li class="chapter-item expanded "><a href="rust_cobweb.html"><strong aria-hidden="true">4.</strong> Rust runtime modifications</a></li><li class="chapter-item expanded "><a href="cob_marker.html"><strong aria-hidden="true">5.</strong> Custom marker component</a></li><li class="chapter-item expanded affix "><li class="part-title">Final tutorial notes</li><li class="chapter-item expanded "><a href="cob_organise.html"><strong aria-hidden="true">6.</strong> Cob file organisation</a></li><li class="chapter-item expanded "><a href="quick_notes.html"><strong aria-hidden="true">7.</strong> Quick notes</a></li><li class="chapter-item expanded affix "><li class="part-title">Cookbook section</li><li class="chapter-item expanded affix "><li class="part-title">Common errors</li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">8.</strong> errors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cobweb book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Cobweb is a UI and asset-management framework for the bevy game engine.</p>
<h2 id="cobweb-features"><a class="header" href="#cobweb-features">Cobweb Features</a></h2>
<ul>
<li>Custom scene format called COB</li>
<li>Localization framework (text, fonts, images, audio)</li>
<li>Font family API</li>
<li>Built-in UI widgets and color palettes</li>
<li>Asset management tools</li>
<li>And many quality of life features.</li>
</ul>
<p>This book is intended to give you a starting point for making your own UI.</p>
<h2 id="structure-of-the-book"><a class="header" href="#structure-of-the-book">Structure of the book</a></h2>
<p>We will start off with the most basic example possible from there the book
will split off into recipes that you can browse as you need them for your
own application</p>
<p>A final section will cover some common errors</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<p>Lets make an empty project to test this out</p>
<p><code>cargo new cobweb_test</code></p>
<p><code>cd cobweb_test/</code></p>
<p>This book won't be making any distinction between cobweb and cobweb_ui
<code>cargo add bevy_cobweb</code></p>
<p><code>cargo add bevy_cobweb_ui -F hot_reload</code></p>
<p>We are definitely adding hot reloading, but you can remove on your release version.</p>
<h2 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h2>
<p>you can optionally install syntax highlighting for the cob files we will be using</p>
<p><a href="https://github.com/UkoeHB/bevy_cobweb_ui">instructions here</a></p>
<h2 id="rust-code"><a class="header" href="#rust-code">Rust Code</a></h2>
<p>set your main to be as below.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;)
{
    c.spawn(Camera2d);
    c.ui_root().load_scene(("main.cob", "main_scene"), &amp;mut s);
}

//-------------------------------------------------------------------------------------------------------------------

fn main()
{
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load("main.cob")
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>This will add systems to handle loading of your files and other plumbing
<code>.add_plugins(CobwebUiPlugin)</code></p>
<p>This tells cobweb to load this file
<code>.load("main.cob")</code></p>
<p>When all the cob files are loaded this will call our setup ui
<code>.add_systems(OnEnter(LoadState::Done), build_ui)</code></p>
<p>make a new ui with its own root node
<code>c.ui_root().load_scene(("main.cob", "main_scene"), &amp;mut s);</code></p>
<h2 id="cob-code"><a class="header" href="#cob-code">COB code</a></h2>
<p>Create a new folder called <code>assets</code></p>
<p>Create a new file called <code>main.cob</code></p>
<p>add in the following code</p>
<pre><code>#scenes
"main_scene"
    TextLine{ text: "Hello, World!" }
</code></pre>
<p>Now lets run the program we have our first bevy cobweb program, next chapter we can start making changes <em>Without recompiling</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cob-files"><a class="header" href="#cob-files">Cob files</a></h1>
<p>Cob allows you to separate your UI from your code, in addition to enabling hot reloading of changes.
Cob is whitespace-sensitive.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>Cob files are made up of sections. For now, we will explore one type of section.</p>
<h3 id="scenes"><a class="header" href="#scenes">Scenes</a></h3>
<p>Scenes are declared by the <code>#scenes</code> keyword. Scenes are given a name. In our example,
we use "main_scene"... extremely creative.
Scenes are the top-level nodes that we load in Cobweb.
We will need to recompile when we add scenes.</p>
<h4 id="extending-our-example"><a class="header" href="#extending-our-example">Extending our example.</a></h4>
<p>First, rerun the program if you have closed it.
We want to see the hot reloading in action.</p>
<p>Let's change our cob file to be something like this:</p>
<pre><code>#scenes
"main_scene"
    TextLine{ text: "Hello, World!, I am writing using cobweb " }
</code></pre>
<h4 id="loadables"><a class="header" href="#loadables">Loadables</a></h4>
<p>Loadables are Rust types that can be added to the scene nodes.
For now, we will only explore one type of loadable:</p>
<p>Types that implement the <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/loading/trait.Instruction.html">instruction trait</a></p>
<p><code>TextLine</code> is an example of a loadable.</p>
<p>*Loadables should not have a space between the opening <code>{</code></p>
<p>Lets add another
<code>AbsoluteNode</code></p>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40% top:30vh }
    TextLine{ text: "Hello, World!, I am writing using cobweb" }

</code></pre>
<p>We have now moved the text around you can also experiment with other units such as <code>40px 40vw</code></p>
<p>Separate fields are not comma separated.</p>
<p>Lets try another loadable <code>BackGroundColor</code></p>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40% }
    BackgroundColor(#FFFF00)
    TextLine{ text: "Hello, World!, I am writing using cobweb " }

</code></pre>
<p>We can see this has poor contrast without recompiling!</p>
<p>Hex values are built into cobweb as colour</p>
<h4 id="animations"><a class="header" href="#animations">Animations</a></h4>
<p>lets add hovering effects we will start off by changing  the background colours based on user hovering.</p>
<h5 id="hovering-and-pressing"><a class="header" href="#hovering-and-pressing">Hovering and pressing</a></h5>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40% }
    TextLine{ text: "Hello, World!, I am writing using cobweb " }
    
    Animated&lt;BackgroundColor&gt;{
        idle:#FF0000 // You can input colours in other formats
        hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
        press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
    }
</code></pre>
<p>Animated is a loadable that works with implementers of the <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/sickle_ext/trait.AnimatableAttribute.html">AnimatableAttribute trait</a>
One example implementer is background colour</p>
<h4 id="next"><a class="header" href="#next">Next</a></h4>
<p>Next we will look at how we know which fields we can use based on the documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loadable-fields"><a class="header" href="#loadable-fields">Loadable fields</a></h1>
<p>So far you have just given the fields to modify, this page aims to explain the different data types in cob files.
When you read the documentation of each loadable hopefully you will be able to easily implement it.</p>
<p>Rerun your program if you have closed it.</p>
<h2 id="node-shadow"><a class="header" href="#node-shadow">Node shadow</a></h2>
<p>Lets start with adding a <code>NodeShadow</code> to our example the documentation can be found <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/ui_bevy/struct.NodeShadow.html">here</a></p>
<p>At the time of writing looked like this</p>
<pre><code>pub struct NodeShadow {
    pub color: Color,
    pub x_offset: Val,
    pub y_offset: Val,
    pub spread_radius: Val,
    pub blur_radius: Val,
}
</code></pre>
<p>lets start with val before color as it is slightly simpler</p>
<h3 id="val"><a class="header" href="#val">Val</a></h3>
<p>Val variants can be written with special units (px, %, vw, vh, vmin, vmax) and the keyword auto.
For example, 10px is equivalent to Px(10).</p>
<h3 id="color"><a class="header" href="#color">Color</a></h3>
<p>In our previous examples we have loaded color using both RGB and HSLA</p>
<h4 id="hex"><a class="header" href="#hex">Hex</a></h4>
<p>Hex colours are a special data in cob and can just be written as <code>#FF00FF</code> with an implied alpha of <code>FF</code>
you can also add an explicit alpha by adding in extra digits <code>#FF00FFEE</code></p>
<h4 id="newtype-collapsing"><a class="header" href="#newtype-collapsing">NewType collapsing</a></h4>
<p>Instead of peeling, loadable newtypes and newtype enum variants use newtype collapsing.
Newtypes are collapsed by discarding ‘outer layers’.</p>
<p>An example we have used for HSLA</p>
<pre><code class="language-rs">Color::Hsla(Hsla {
    hue: 240.0,
    saturation:1.0,
    lightness: 0.5,
    alpha:1.0,
})
</code></pre>
<p><code>Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }</code></p>
<h3 id="defaults"><a class="header" href="#defaults">Defaults</a></h3>
<p>Not all fields need to be filled out every field left blank we will be defaulted.</p>
<h3 id="adding-nodeshadow"><a class="header" href="#adding-nodeshadow">Adding NodeShadow</a></h3>
<p>With the above information we have enough to create our node shadow</p>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40% }
    TextLine{ text: "Hello, World!, I am writing using cobweb " }
    NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px } //our new shadow node
    Animated&lt;BackgroundColor&gt;{
        idle:#FF0000 // You can input colours in other formats
        hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
        press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
    }
    
</code></pre>
<p>Done</p>
<h3 id="floats"><a class="header" href="#floats">Floats</a></h3>
<p>Floats are written similar to how they are written in rust.</p>
<ul>
<li>Scientific notation: 1.2e3 or 1.2E3.</li>
<li>Integer-to-float conversion: 1 can be written instead of 1.0.</li>
<li>Keywords inf/-inf/nan: infinity, negative infinity, NaN.</li>
</ul>
<p>lets go ahead with an example using <code>size</code> in <code>TextLine</code></p>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40% }
    TextLine{ text: "Hello, World!, I am writing using cobweb " size:150 } //change the textline here
    NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
    Animated&lt;BackgroundColor&gt;{
        idle:#FF0000 // You can input colours in other formats
        hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
        press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
    }

</code></pre>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>String parsing</p>
<p>Strings are handled similar to how rust string literals are handled.</p>
<ul>
<li>Enclosed by double quotes (e.g. "Hello, World!").</li>
<li>Escape sequences: standard ASCII escape sequences are supported (\n, \t, \r, \f, ", \), in addition to Unicode code points (\u{..1-6 digit hex..}).</li>
<li>Multi-line strings: a string segment that ends in \ followed by a newline will be concatenated with the next non-space character on the next line.</li>
<li>Can contain raw Unicode characters</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-rust-to-update-text"><a class="header" href="#using-rust-to-update-text">Using rust to update text</a></h1>
<p>We will be using rust to modify the contents of text at runtime (no hot reloading).</p>
<h2 id="modify-the-cob-file"><a class="header" href="#modify-the-cob-file">Modify the cob file</a></h2>
<p>Lets setup the cob file as below.</p>
<pre><code>"scene"
    AbsoluteNode{left:40%}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here

</code></pre>
<p>We split position logic into a child node called <code>cell</code> which holds most of the positioning and styling logic.
<code>cell</code> has a child called <code>text</code>. Text is a minimal node responsible for just text stuff.</p>
<h3 id="why-we-split-text-from-styling"><a class="header" href="#why-we-split-text-from-styling">Why we split text from styling</a></h3>
<p>This is more of a html/CSS pattern then anything particular with cobweb but it is worth mentioning here.</p>
<p>It just turns out to be easier to position nodes then it is to position then text.</p>
<h2 id="rust"><a class="header" href="#rust">Rust</a></h2>
<div class="warning">
<p>At the time of writing the latest release does not have all the functions.</p>
<p>you may need to follow the main branch as below.</p>
<pre><code>bevy_cobweb_ui = { git = "https://github.com/UkoeHB/bevy_cobweb_ui.git", features = [
  "hot_reload",
] }
</code></pre>
</div>
<h3 id="updating-text-at-runtime"><a class="header" href="#updating-text-at-runtime">Updating text at runtime</a></h3>
<p>Lets change the rust code to be as below.</p>
<pre><code class="language-rs">fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");
        });
}
</code></pre>
<p>We have changed <code>load_scene</code> to be <code>load_scene_and_edit</code>.</p>
<p>When we load <code>"main_scene"</code> in the cob file we automatically load all the child nodes recursively,
The second argument is a closure where we can use loaded scenes similar to commands along with
cobwebs extended commands.</p>
<p>Inside the closure we call <code>get(cell::text)</code> which is basically a path syntax to go straight to the
text node, it also possible to call <code>edit</code> on cell then call <code>update_text</code> inside the resulting closure.</p>
<p>Recompile and run the program you will see your text has changed to reflect the rust code.</p>
<h3 id="spawning-new-nodes"><a class="header" href="#spawning-new-nodes">Spawning new nodes</a></h3>
<p>Cobweb can also spawn multiple top level scenes lets start with an example.</p>
<p>Below we have our new scene called <code>number_text</code>.</p>
<p>If the concept of scenes was a bit confusing before this should clarify it a bit more.</p>
<pre><code>#scenes
"scene"
    AbsoluteNode{left:40%,flex_direction:Column}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here


"number_text"
    "cell"
        "text"
            TextLine{text:"placeholder"}
</code></pre>
<p>Now lets change our rust code to spawn some scenes.</p>
<pre><code class="language-rs">fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            //Spawning new ui nodes
            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.get("cell::text").update_text(i.to_string());
                });
            }
        });
}
</code></pre>
<p>We now have some numbers that appear based on your run code.
We can still modify the cob files and change styling</p>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40%,flex_direction:Column}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here


"number_text"
    "cell"
        "text"
            TextLine{text:"placeholder"}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}) //still can change at runtime
</code></pre>
<h4 id="making-nodes-interactive"><a class="header" href="#making-nodes-interactive">Making nodes interactive</a></h4>
<p>Setting our UI to react on user interfaces is essential, and easy first we need to load the interactive components.</p>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40%,flex_direction:Column}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here


"number_text"
    "cell"
        "text"
            TextLine{text:"placeholder"}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}) //still can change at runtime
            Interactive //Loads listeners for user interaction

</code></pre>
<p>Now we can use <code>on_pressed</code> in closures.</p>
<pre><code class="language-rs">fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We can write arbitrary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
        });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-marker-component"><a class="header" href="#custom-marker-component">Custom marker component</a></h1>
<p>In bevy its common to have marker components, that is components which contains no data,
but does mark the entity as having some user defined purpose there are at least two ways to do this.</p>
<p>Before looking at either approach we should set the a common goal and setup code.</p>
<ul>
<li>Add an exit button to the interface.</li>
<li>Add a button to despawn the interface.</li>
<li>On despawning add another button to respawn the interface.</li>
</ul>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load("main.cob")
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<pre><code>#scenes
"main_scene"
    AbsoluteNode{left:40%,flex_direction:Column}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here


"number_text"
    "cell"
        "text"
            TextLine{text:"placeholder"}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}) //still can change at runtime
            Interactive //Loads listeners for user interaction


"exit_button"
    TextLine{text:"Exit"}
    Interactive
"despawn_button"
    TextLine{text:"Despawn"}
    Interactive
"respawn_button"
    TextLine{text:"Respawn"}
    Interactive
</code></pre>
<p>I could just have easily made exit and despawn child of <code>main_scene</code> there is no significance to my decision.</p>
<h2 id="rust-approach"><a class="header" href="#rust-approach">Rust approach</a></h2>
<p>Lets look at the first way of doing this using what is likely to be a more familiar approach to you.</p>
<pre><code class="language-rs">#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene.insert(MainInterface); //add this to the scene
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
        });
}
</code></pre>
<p>Now lets add despawning button, we can use <code>on_pressed</code> along with a normal bevy query.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene.insert(MainInterface);
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
            loaded_scene.load_scene_and_edit(("main.cob", "despawn_button"), |loaded_scene| {
            //button here despawns notice this looks like a normal bevy query
                loaded_scene.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        //I usually use tiny_bail instead of all this unwrapping
                        commands
                            .get_entity(interface_query.get_single().unwrap())
                            .unwrap()
                            .despawn_recursive();
                    },
                );
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load("main.cob")
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>Now lets add the exit button which will not any more difficult</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.spawn(Camera2d);
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene.insert(MainInterface);
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
            loaded_scene.load_scene_and_edit(("main.cob", "despawn_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single().unwrap())
                            .unwrap()
                            .despawn_recursive();
                    },
                );
            });
            loaded_scene.load_scene_and_edit(("main.cob", "exit_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |mut commands: Commands, focused_windows: Query&lt;Entity, With&lt;Window&gt;&gt;| {
                        let window = focused_windows.get_single().unwrap();
                        commands.entity(window).despawn();
                    },
                );
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load("main.cob")
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<h3 id="spawn-other-interface"><a class="header" href="#spawn-other-interface">spawn other interface</a></h3>
<p>Lets add a function for spawning the new interface</p>
<pre><code class="language-rs">fn spawn_other_interface(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.ui_root()
        .load_scene_and_edit(("main.cob", "respawn_button"), &amp;mut s, |loaded_scene| {
            //TODO respawning main interface
        });
}
</code></pre>
<p>Now call it on despawn</p>
<pre><code class="language-rs">            loaded_scene.load_scene_and_edit(("main.cob", "despawn_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single().unwrap())
                            .unwrap()
                            .despawn_recursive();
                        commands.run_system_cached(spawn_other_interface);
                    },
                );
            });
</code></pre>
<p><code>run_system_cached</code> is a convenient way to call a function arbitrarily when you don't need to supply data.
Consider observers if you do.</p>
<p>We can now despawn the main interface, another approach could have been using an observer with an entity code.</p>
<p>All there is to do now is fill in the respawn logic there is not much to discuss so will see the code below.</p>
<pre><code>use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component)]
struct MainInterface;

fn build_ui(mut c: Commands) {
    c.spawn(Camera2d);
    c.run_system_cached(spawn_main_interface);
}

fn spawn_main_interface(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
            loaded_scene.insert(MainInterface);
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
            loaded_scene.load_scene_and_edit(("main.cob", "despawn_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single().unwrap())
                            .unwrap()
                            .despawn_recursive();
                        commands.run_system_cached(spawn_other_interface);
                    },
                );
            });
            loaded_scene.load_scene_and_edit(("main.cob", "exit_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |mut commands: Commands, focused_windows: Query&lt;Entity, With&lt;Window&gt;&gt;| {
                        let window = focused_windows.get_single().unwrap();
                        commands.entity(window).despawn();
                    },
                );
            });
        });
}

fn spawn_other_interface(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.ui_root()
        .load_scene_and_edit(("main.cob", "respawn_button"), &amp;mut s, |loaded_scene| {
            let entity = loaded_scene.id();
            loaded_scene.on_pressed(move |mut commands: Commands| {
                commands.get_entity(entity).unwrap().despawn_recursive();
                commands.run_system_cached(spawn_main_interface);
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .load("main.cob")
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>In spawn other interface we do get the entity using the <code>id</code> method.</p>
<h2 id="moving-maininterface-to-a-cob-file"><a class="header" href="#moving-maininterface-to-a-cob-file">Moving MainInterface to a cob file</a></h2>
<p>We first need to implement the <code>Instruction</code> trait for this item and derive a few more traits.</p>
<pre><code class="language-rs">
#[derive(Component, Default, PartialEq, Reflect)]
struct MainInterface;

impl Instruction for MainInterface {
    fn apply(self, _entity: Entity, _world: &amp;mut World) {}

    fn revert(_entity: Entity, _world: &amp;mut World) {}
}
</code></pre>
<p>We don't need the arguments in this case so we can ignore them.
now lets remove <code>insert code</code> and register the component type.</p>
<pre><code class="language-rs">use bevy::prelude::*;
use bevy_cobweb_ui::prelude::*;

//-------------------------------------------------------------------------------------------------------------------

#[derive(Component, Default, PartialEq, Reflect)]
struct MainInterface;

impl Instruction for MainInterface {
    fn apply(self, _entity: Entity, _world: &amp;mut World) {}

    fn revert(_entity: Entity, _world: &amp;mut World) {}
}

fn build_ui(mut c: Commands) {
    c.spawn(Camera2d);
    c.run_system_cached(spawn_main_interface);
}

fn spawn_main_interface(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.ui_root()
        .load_scene_and_edit(("main.cob", "main_scene"), &amp;mut s, |loaded_scene| {
        //No longer have insert here
            loaded_scene
                .get("cell::text")
                .update_text("My runtime text");

            for i in (0..=10).into_iter() {
                loaded_scene.load_scene_and_edit(("main.cob", "number_text"), |loaded_scene| {
                    loaded_scene.edit("cell::text", |loaded_scene| {
                        loaded_scene.update_text(i.to_string());
                        loaded_scene.on_pressed(move|/* We write arbitary bevy parameters here*/|{
                            println!("You clicked {}",i);
                        });
                    });
                });
            }
            loaded_scene.load_scene_and_edit(("main.cob", "despawn_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |interface_query: Query&lt;Entity, With&lt;MainInterface&gt;&gt;,
                     mut commands: Commands| {
                        commands
                            .get_entity(interface_query.get_single().unwrap())
                            .unwrap()
                            .despawn_recursive();
                        commands.run_system_cached(spawn_other_interface);
                    },
                );
            });
            loaded_scene.load_scene_and_edit(("main.cob", "exit_button"), |loaded_scene| {
                loaded_scene.on_pressed(
                    |mut commands: Commands, focused_windows: Query&lt;Entity, With&lt;Window&gt;&gt;| {
                        let window = focused_windows.get_single().unwrap();
                        commands.entity(window).despawn();
                    },
                );
            });
        });
}

fn spawn_other_interface(mut c: Commands, mut s: ResMut&lt;SceneLoader&gt;) {
    c.ui_root()
        .load_scene_and_edit(("main.cob", "respawn_button"), &amp;mut s, |loaded_scene| {
            let entity = loaded_scene.id();
            loaded_scene.on_pressed(move |mut commands: Commands| {
                commands.get_entity(entity).unwrap().despawn_recursive();
                commands.run_system_cached(spawn_main_interface);
            });
        });
}

//-------------------------------------------------------------------------------------------------------------------

fn main() {
    App::new()
        .add_plugins(bevy::DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                window_theme: Some(bevy::window::WindowTheme::Dark),
                ..default()
            }),
            ..default()
        }))
        .add_plugins(CobwebUiPlugin)
        .register_component_type::&lt;MainInterface&gt;() //This is what allows cob to load this item
        .load("main.cob")
        .add_systems(OnEnter(LoadState::Done), build_ui)
        .run();
}
</code></pre>
<p>Lets now add this to our COB file.</p>
<pre><code>#scenes
"main_scene"
    MainInterface
    AbsoluteNode{left:40%,flex_direction:Column}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here


"number_text"
    "cell"
        "text"
            TextLine{text:"placeholder"}
            TextLineColor(Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}) //still can change at runtime
            Interactive //Loads listeners for user interaction


"exit_button"
    TextLine{text:"Exit"}
    Interactive //Loads listeners for user interaction
"despawn_button"
    TextLine{text:"Despawn"}
    Interactive //Loads listeners for user interaction
"respawn_button"
    TextLine{text:"Respawn"}
    Interactive //Loads listeners for user interaction
</code></pre>
<p>We are now done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cob-file-organisation"><a class="header" href="#cob-file-organisation">Cob file organisation</a></h1>
<h2 id="defs"><a class="header" href="#defs">defs</a></h2>
<p>Cob files can have variables so you can define common values, that can be used all over your cob files.
This will allow you to make changes in one place to impact multiple nodes.</p>
<p>Lets do an example.</p>
<pre><code>//defs is another type of section so far we have only been doing scenes
#defs
$text_colour = Hsla{hue:45 saturation:1.0 lightness:0.5 alpha:1.0}

#scenes
"main_scene"
    MainInterface
    AbsoluteNode{left:40%,flex_direction:Column}
    "cell"
        Animated&lt;BackgroundColor&gt;{
            idle:#FF0000 // You can input colours in other formats
            hover:Hsla{ hue:120 saturation:1.0 lightness:0.50 alpha:1.0 }
            press:Hsla{ hue:240 saturation:1.0 lightness:0.50 alpha:1.0 }
        }
        NodeShadow{color:#FF0000 spread_radius:10px blur_radius:5px }
        "text"
            TextLine{text:"Hello, World!, I am writing using cobweb "  } // change the textline here


"number_text"
    "cell"
        "text"
            TextLine{text:"placeholder"}
            TextLineColor($text_colour) //still can change at runtime
            Interactive //Loads listeners for user interaction


"exit_button"
    TextLine{text:"Exit"}
    TextLineColor($text_colour) //still can change at runtime
    Interactive //Loads listeners for user interaction
"despawn_button"
    TextLine{text:"Despawn"}
    TextLineColor($text_colour) //still can change at runtime
    Interactive //Loads listeners for user interaction
"respawn_button"
    TextLine{text:"Respawn"}
    TextLineColor($text_colour) //still can change at runtime
    Interactive //Loads listeners for user interaction
</code></pre>
<h2 id="mainifests-and-imports"><a class="header" href="#mainifests-and-imports">mainifests and imports</a></h2>
<p>You can further extend this over many files using <code>manifest and imports</code>
If no scenes are loaded from the previous file the</p>
<pre><code>#manifest
"ui/colour_scheme.cob" as cs

#import
cs as colours
</code></pre>
<p>which can be referred using scoping and the <code>$</code> character</p>
<pre><code>BackgroundColor($colours::background_colour)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-notes"><a class="header" href="#quick-notes">Quick notes</a></h1>
<p>This section will mention notes that did not come up in the tutorial but may still be helpful for you.</p>
<h2 id="loading-cob-files"><a class="header" href="#loading-cob-files">Loading Cob files</a></h2>
<p>When you have a cob file that defines scenes, you must register with the app by using syntax as below
<code>.load("main.cob")</code></p>
<h3 id="waiting-for-loadstatedone"><a class="header" href="#waiting-for-loadstatedone">Waiting for LoadState::Done</a></h3>
<p>If your UI is to appear at the start of the game then you should wait to ensure cobweb has had a chance to read it.
<code>.add_systems(OnEnter(LoadState::Done), build_ui)</code></p>
<p>If you UI comes up in response to player actions then calling it using observers or events should be fine as UI would have been read by cobweb.</p>
<h2 id="other-features-not-covered-at-least-for-now"><a class="header" href="#other-features-not-covered-at-least-for-now">Other features not covered (at least for now!)</a></h2>
<h3 id="cobweb-has-react-features"><a class="header" href="#cobweb-has-react-features">Cobweb has React features.</a></h3>
<p>Some examples can be found <a href="https://github.com/UkoeHB/bevy_cobweb_ui/tree/main/examples">here</a></p>
<p>You can use broadcasts to refresh your ui, <code>update_on(broadcast::&lt;MyArbitaryStruct&gt;(),|/*bevy query*/|{});</code>
Call it using <code>commands.react().broadcast(MyArbitaryStruct)</code>.</p>
<p>There are others as well.</p>
<h3 id="other-features"><a class="header" href="#other-features">Other features</a></h3>
<ul>
<li>RadioButtons, hope to have an example later can also be useful for tabbing, <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/sickle_ext/index.html">A good starting point</a> .</li>
<li>localization there is an example in the link above, documentation <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/localization/index.html">here</a>.</li>
<li>commands</li>
</ul>
<h2 id="loading-documentation"><a class="header" href="#loading-documentation">Loading documentation.</a></h2>
<p>you can find more details about cob files <a href="https://docs.rs/bevy_cobweb_ui/latest/bevy_cobweb_ui/loading/index.html">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">errors</a></h1>
<h2 id="forgetting-to-add-interactive-to-nodes"><a class="header" href="#forgetting-to-add-interactive-to-nodes">Forgetting to add Interactive to nodes</a></h2>
<p>If you node defined in the cob file has to be interacted with make sure you put in <code>Interactive</code></p>
<h2 id="odd-lifetime-errors-usually-about-static-lifetimes"><a class="header" href="#odd-lifetime-errors-usually-about-static-lifetimes">Odd lifetime errors, usually about static lifetimes</a></h2>
<p>If you capture closures like in <code>on_pressed</code> make sure you use move and clone anything you need.</p>
<h2 id="trying-to-load-non-top-level-scenes"><a class="header" href="#trying-to-load-non-top-level-scenes">Trying to load non top level scenes</a></h2>
<p>Only the top level scenes can be loaded independently.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
